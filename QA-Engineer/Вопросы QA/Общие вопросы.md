#### 1. Что такое тестирование и какая цель тестирования?

Тестирование это процесс проверки что ПО соответствует требованиям и работает как ожидается. Главная цель тестирования это выпустить качественный продукт, но согласно ISBTQ цели тестирования могут варьироваться в зависимости от контекста конкретной тестируемой системы и в цели тестирования может входить проверка, что все указанные требования выполнены, так же может входить предотвращение дефектов и обнаружение отказов и дефектов

#### 2. Почему вы решили пойти в тестирование?

Мне нравится QA, я вижу здесь большие перспективы и множество точек роста для себя. Можно глубже работать с требованиями, можно погружаться в тест-анализ, можно уйти в автоматизацию, где есть также разные точки развития (мобилок, апи, веб), можно заниматься нагрузочным тестированием. При это мне нравится, что тестировщики лучше всех знают как работает продукт, со всеми коммуницируют 

#### 3. Жизненный цикл бага

Жизненный цикл бага может отличаться от workflow, который настроен в компании и в зависимости от того, баг заведен в продакшене или на функционал который находится в тестировании. Обычно мы заводим баг и он находит в статусе Open. После того как разработчик берет баг в работу, он переходит в статус In progress. После того как разработчик пофиксил баг, он отдает его в ревью, баг отправляется в статус Wait for review. Как начинается ревью баг переходит в статус Review. Если с ревью все хорошо, баг переходит в статус Wait for test. Как только мы начинаем тестировать исправление по багу, мы переведем задачу в Testing
- Open
- Open -> In progress
- In progess -> Wait for Review
- Wait for Review -> Review
- Review -> Wait for test
- Wait for test -> Testing
#### 4. Чем тест-кейс отличается от чек-листа?

**Тест-кейс** - подробное описание конкретного теста, который нужно выполнить. Включает в себя: шаги для выполнения, ожидаемый результат и критерий успешного прохождения теста. Чаще всего используется для тщательного тестирования конкретной фичи

**Чек-лист** - список элементов или шагов, которым нужно проверить без детального описания того, как это нужно сделать. Обычно создаются в виде списка, где каждый элемент представляет из себя конкретную проверку, может использоваться для более общего и быстрого контроля качества, а также для повторяющихся задач

Тест-кейсы применяются когда нужно более глубокое и структурированное тестирование, особенно полезно при тестировании новых функций или критически важных частей программы. Чек-листы используются для повторяющихся проверок и быстрого обзора

#### 5. Что такое регрессионное тестирование? Для чего оно нужно?

**Регрессионное тестирование** направлено на обнаружение новых ошибок в программе после внесения нового кода в программу. Основная идея такого тестирования заключается  в том чтобы удостовериться, что новые изменения не привели к появлению новых ошибок в уже существующей функциональности 

#### 6. Чем отличается тест-кейс от баг-репорта?

**Тест-кейс** направлен на проверку фичи, это документ, который тестировщик использует для проведения теста. 

**Баг-репорт** направлен на фиксацию бага, это документ который создается после обнаружения ошибки и предназначен для коммуникации между тестировщиками и разработчиками. 

Хороший тест-кейс и баг-репорт имеют шаги и ожидаемый результат, но в баг-репорте есть фактический результат

#### 7. Какие техники тест-дизайна вы знайте?

Самые распространенные техники это граничные значения, классы эквивалентности, попарное тестирование, диаграмма состояния переходов и таблицы принятия решений

Тест-дизайн — это процесс создания тестовых сценариев и тест-кейсов, направленных на проверку правильности работы системы. В тестировании используются различные техники тест-дизайна для покрытия как можно большего числа сценариев с минимальными затратами. Рассмотрим наиболее популярные техники тест-дизайна:

1. **Эквивалентное разбиение (Equivalence Partitioning)**

- **Суть:** Разделение входных данных на несколько групп (классов эквивалентности), где данные в одной группе предполагаются обработанными системой одинаково. Предполагается, что если одно значение из группы работает корректно, то и остальные значения из этой группы тоже будут работать правильно.
- **Пример:** Если поле принимает значения от 1 до 100, можно создать три класса эквивалентности:
    - Значения меньше 1 (например, 0).
    - Значения от 1 до 100 (например, 50).
    - Значения больше 100 (например, 101).

2. **Анализ граничных значений (Boundary Value Analysis)**

- **Суть:** Проверка системы на значениях, находящихся на границах классов эквивалентности, так как ошибки часто возникают на границах этих классов.
- **Пример:** Для входных данных от 1 до 100 тестируются значения 1, 100, а также значения на одну единицу больше и меньше границ: 0, 2, 99, 101.

3. **Попарное тестирование (Pairwise Testing)**

- **Суть:** Выбор минимального количества комбинаций параметров, чтобы покрыть все возможные пары значений параметров. Это позволяет уменьшить количество тестов, сохраняя при этом хорошее покрытие.
- **Пример:** Если тестируется форма с тремя полями, каждое из которых может принимать по 3 значения, попарное тестирование сократит количество тестов, покрывая все пары значений.

4. **Метод таблицы принятия решений (Decision Table Testing)**

- **Суть:** Создание таблицы, которая описывает все возможные комбинации условий и соответствующие им действия. Эта техника полезна, когда нужно протестировать сложную бизнес-логику.
- **Пример:** В интернет-магазине для определенной категории пользователей могут действовать разные скидки. Таблица принятия решений поможет учесть все комбинации скидок.

5. **Метод пополнения состояний (State Transition Testing)**

- **Суть:** Тестирование системы путем перехода между различными состояниями на основе событий или входных данных. Эта техника полезна для систем, где поведение зависит от предыдущих состояний.
- **Пример:** В банкомате, после ввода правильного PIN-кода, система переходит в состояние ожидания выбора операции.

6. **Таблицы истинности и причинно-следственный граф (Cause-Effect Graphing)**

- **Суть:** Техника используется для тестирования систем с множеством условий и эффектов. Причины (inputs) и следствия (outputs) моделируются в виде графа, что помогает выявить зависимости между ними и создать тесты.
- **Пример:** Проверка логики расчета скидок, где различные комбинации условий могут привести к разным значениям скидки.

7. **Метод вычерпывания (Exhaustive Testing)**

- **Суть:** Тестирование всех возможных комбинаций входных данных. Этот метод используется редко из-за его ресурсоемкости и применяется только для очень маленьких и критичных систем.
- **Пример:** Проверка всех возможных комбинаций ввода для функции с двумя булевыми параметрами (2^2 = 4 комбинации).

8. **Тестирование с использованием диаграмм активностей и сценариев (Use Case Testing)**

- **Суть:** Создание тестов на основе сценариев использования (use cases), которые описывают взаимодействие пользователя с системой. Эта техника помогает проверить систему с точки зрения пользователя.
- **Пример:** В интернет-банке сценарий перевода средств может включать в себя шаги выбора счета, ввода суммы и подтверждения операции. Тестирование охватывает все эти шаги.

9. **Метод тестирования на основе ошибок (Error Guessing)**

- **Суть:** Интуитивное тестирование, основанное на опыте тестировщика. Тестировщик пытается предугадать, где в системе могут возникнуть ошибки, и создает тесты для проверки этих мест.
- **Пример:** Тестировщик может предположить, что система может некорректно обрабатывать пустые поля или специфические символы в вводе.

10. **Метод тестирования диаграммы состояний (State Transition Testing)**

- **Суть:** Основан на тестировании изменений состояний системы в ответ на события или условия. Полезно для систем, которые могут находиться в различных состояниях, и поведение которых зависит от этих состояний.
- **Пример:** Проверка банкомата, где разные действия пользователя (ввод PIN, выбор операции) приводят к изменениям состояний (ожидание ввода PIN, выбор операции и т.д.).

Использование этих техник позволяет эффективно и систематично разрабатывать тестовые сценарии, которые обеспечат максимально возможное покрытие системы с минимальными усилиями. Выбор конкретной техники зависит от характера системы, требований и опыта тестировщика.

#### 8. Верификация валидация

**Верификация** проверяет, соответствует ли продукт ТЗ.

**Валидация** проверяет соответствует продукт ожиданию пользователя. 

К примеру если вы разрабатываете интернет-банкинг, верификация будет включать в себя проверку того, что программа правильно обрабатывается банковские транзакции в соответствии с техническими стандартами. В то время как валидация будет включать в себя тестирование программы с реальными клиентами банковскими, чтобы удостовериться, что она удовлетворяет его потребностям и легко используется 

#### 9. SDLC и STLC

**SDLC (Software Development Life Cycle)** - процесс, который описывает последовательные этапы разработки ПО идеи до завершения проекта и включает в себя такие этапы: 
- планирование
- анализ
- проектирование
- разработка
- тестирование
- развертывание 
- поддержка

**STLC (Software Testing Lifecycle)** - жизненный цикл тестирования ПО. Включает в себя следующие этапы:
- планирование тестирования
- создание тест-кейсов
- выполнение тестов
- анализ результатов
- создание отчетов

#### 10. Какие виды, уровни, методы тестирования вы знаете?

Тестирование программного обеспечения (ПО) включает в себя множество видов, уровней и методов, каждый из которых направлен на обнаружение ошибок и улучшение качества продукта. Давайте рассмотрим основные из них:

**1. Виды тестирования**

- **Функциональное тестирование**: Проверяет, соответствует ли ПО функциональным требованиям, т.е. выполняет ли оно то, что от него ожидается.
- **Нефункциональное тестирование**: Оценивает такие аспекты, как производительность, удобство использования, безопасность и т.д.
- **Ручное тестирование**: Тестировщик выполняет тестовые сценарии вручную, без использования автоматизированных средств.
- **Автоматизированное тестирование**: Для выполнения тестов используются специальные инструменты, которые могут автоматически выполнять тестовые сценарии и проверять результаты.
- **Регрессионное тестирование**: Проверяет, что изменения в коде не привели к новым ошибкам в ранее работающем функционале.
- **Тестирование безопасности**: Направлено на обнаружение уязвимостей и оценку безопасности приложения.
- **Тестирование производительности**: Включает стресс-тестирование, нагрузочное тестирование и тестирование стабильности, чтобы определить, как система работает при различных условиях нагрузки.
- **Тестирование совместимости**: Проверяет, корректно ли работает ПО в различных окружениях (на разных ОС, браузерах, устройствах и т.д.).
- **Тестирование удобства использования (юзабилити-тестирование)**: Оценивает удобство и интуитивность интерфейса для пользователя.

**2. Уровни тестирования**

- **Модульное тестирование (Unit Testing)**: Тестирование отдельных модулей или компонентов программы, как правило, на уровне исходного кода.
- **Интеграционное тестирование**: Проверка взаимодействия между различными модулями или компонентами, чтобы убедиться, что они правильно работают вместе.
- **Системное тестирование**: Тестирование всей системы в целом, чтобы убедиться, что все компоненты работают вместе и соответствуют требованиям.
- **Приемочное тестирование (Acceptance Testing)**: Оценивает готовность системы к развертыванию и использованию, обычно проводится на стороне клиента или конечного пользователя.

**3. Методы тестирования**

- **Белый ящик (White-box Testing)**: Тестировщик знает внутреннюю структуру или код приложения и использует эту информацию для создания тестов.
- **Черный ящик (Black-box Testing)**: Тестирование проводится без знаний о внутренней структуре системы. Тестировщик проверяет, как система выполняет свои функции на основе спецификаций.
- **Серый ящик (Gray-box Testing)**: Сочетание тестирования "белого" и "черного" ящика, когда тестировщик имеет ограниченные знания о внутренней структуре системы.

#### 11. В чем разница между авторизацией и аутентификацией?

Когда мы авторизуемся на сайте по логину или емайлу, в этот момент у нас происходит идентификация - процесс определения кто вы есть, по уникальному идентификатору (логина или почты). После этого сайт запрашивает пароль и это уже будет аутентификация - процесс проверки, что вы действительно тот кем вы себя представляете, проверка является ли предоставленный пароль правильным и соответствует ли он учентой записи. После успешной аутентификации пользователю предоставляется доступ к определенным ресурсам и функциональности системы в соответствии с его правами, т.е. авторизация - процесс определения , что вы можете делать, когда вы аутентифицированы 

#### 12. Разница между priority и severity?

**Severity** (серьезность) - определяет насколько критичен баг, как он влияет на функциональность продукта, т.е. степень влияния дефекта на работу продукта

**Priority** (приоритет) - указывает на важность исправление дефекта, т.е. порядок в котором разработчик должен решить дефект.

Например вы обнаружили баг, который вызывает крах сайта и это будет высокая серьезность, но проект который вы тестируете близок к завершению или функционал, который вы нашли этот баг скоро удалят, или нужен очень хитрый кейс, чтобы воспроизвести этот баг. Или наоборот, вы заметили небольшой баг верстки на главной страницы сайта, баг не влияет на функциональность сайта. Серьезность у него не высокая, но приоритет будет высоким т.к. это главная страница сайта и ее видят пользователи

#### 13. Расскажите про XML и JSON. В чем между ними разница?

XML и JSON это популярных формата для обмена данными. XML использует разметку в виде открывающихся-закрывающихся тегов. JSON использует формат представляя данные в виде ключ-значение. JSON применяется в веб-разработки и апи. XML поддерживает пространство имен и схему валидации, однако он более громоздок и менее компактен. JSON более легкий, читаемый для человека, более компактный, но менее поддерживает сложные структуры данных и требования к валидации

##### 14. Что такое REST и SOAP? В чем между ними разница?

**REST** является стилем архитектуры описывающие принципы организации веб-системы, использует HTTP-запросы.

**SOAP** - протокол для обмена структурированными информационными сообщениями в веб-службах основанные на XML. 

REST часто считается более простым и эффективным для веб-приложений, в то время как SOAP предоставляет дополнительные функции и может быть предпочтительным в больших и сложных информационных системах интеграции

#### 15. Scram vs Kanban


#### 16. Какие HTTP методы самые безопасные?

Методы GET, HEAD, OPTION считаются безопасными т.к. они не должны изменять состояние сервера. Важно отметить, что безопасность так же зависит от того, как используются эти методы в конкретном контексте приложения и от правильной реализации на стороне сервера.

Методы POST, PUT, DELETE, PATCH считаются менее безопасными. POST может привести к изменению состояния сервера и хранимых данных. PUT как и POST может изменить состояние сервера. DELETE небезопасный метод, поскольку он может привести к удалению данных. PATCH используется для частичного обновления ресурса, поэтому так же может изменить состояние сервера.

#### 17. Какие HTTP методы идемпотентные и неидемпотентные? Что такое идемпотентность?

Методы HTTP делятся на идемпотентные и неидемпотентные в зависимости от того вызывает ли повторное повторение одного же запроса изменения состояния сервера или хранимых данных.

Идемпотентные методы это те которые не изменяют результат запроса при повторном его выполнении. GET, этот метод используется для получения данных с сервера, вызов не должен изменять состояние сервера или хранимых данных и каждое повторение выполнение запроса GET должно возвращать тот же самый результат. HEAD метод аналогичен методу GET, но возвращает только заголовки ответа без тела. PUT используется для обновления существующего ресурса на сервере, он считается идемпотентным, потому что при повторном вызове с теми же данными результат остается неизменным. DELETE используется для удаления ресурса на сервере, так же считается идемпотентным, поскольку удаление ресурса который уже удален не изменит состояние сервера. OPTIONS используется для запроса информации о возможностях сервера, он является идемпотентным.

#### 18. Расскажите про модель OSI. Что это такое?

Модель OSI это способ организации и понимания того, как компьютеры в сети взаимодействуют друг с другом. Она разбита на 7 уровней.
Физический уровень - кабель, оптоволокно, через который передаются электрические сигналы между компьютерами.

- Канальный уровень - в этот момент данные упаковываются в фреймы и каждый компьютер на сети получает свой собственный MAC-адрес (физический адрес)
- Сетевой уровень - решается как эти фреймы будут перемещаться через различные устройства, например маршрутизаторы, чтобы добраться до нужного места в сети
- Транспортный уровень - нп. TCP, который гарантирует доставку данных в нужном порядке и проверяет их на целостность.
- Сеансовый уровень - на этом уровне происходит установление управления и завершения сеанса взаимодействия между приложениями
- Представительный уровень - здесь данные могут быть преобразованы в нужный формат, например: сжаты или закодированы.
- Прикладной уровень - это приложения и сервисы (веб-браузеры, электронная почта, файловые серверы), которые генерирует данные и взаимодействуют с пользователем

#### 19. Расскажите про структуру HTTPS запросы и про коды ответов

HTTP запрос состоит из типа запроса, адреса обращения, HTTP заголовка, структура ответа. В структуре ответа так же как и в запросе есть заголовки.
HTTP статус кода представляют с собой трехзначные числа, которые сервер отправляет в ответ на запрос. Эти коды делятся на пять основных классов, каждый из которых представляет определенную категорию ответа: информационные (100-199), успешные (200-299), перенаправление (300-399), ошибки клиента (400-499), ошибки сервера(500-599).

#### 20. Расскажите про принципы тестирования

Всего семь принципов:
- Тестирование может доказать, что баги есть, но не может доказать, что их нет
- Исчерпывающее тестирование невозможно.
- Тестировать нужно на раннем этапе.
- Скопление багов. Примерно 80% ошибок обнаруживается в 20% функционала.
- Эффект пестицида. Если регулярно не пересматривать тест-кейсы, то баги буду подстраиваться под эти тест-кейсы и тест-кейсы уже будут упускать баги
- Тестирование зависит от контекста
- Ложная информация об отсутствии ошибок. Мы не можем доказать, что багов нет, они есть всегда

#### 21. Какие бывают требования?

Бывают полные и неполные требования. Также, есть функциональные требования - они описывают ожидаемое поведение системы на действие пользователя. Нефункциональные требования включают в себя требования к производительности, безопасности, надежности. Требования к совместимости определяют на каких платформах  или ОС должен работать продукт, а также какие браузеры, устройства или версии ПО он поддерживает. Требования к интерфейсу пользователя описывают как должен выглядеть или вести себя пользовательский интерфейс, включая макеты, цвета, шрифты и взаимодействие элементов управления

#### 22. Что вы будете делать, если вам нужно провести регрессивное тестирование с большим количеством тест-кейсов и если их проходить все, то у вас уйдет на это 8 часов а у вас только два часа? Или вам нужно протестировать какую то большую фичу, к такому то сроку, а ресурсов нет, времени нет и т.д.?

Первым делом, следует довести до тимлида, куалида, пм что не хватает ресурсов. Далле попросил бы в помощь дополнительного тестировщика. Если такой вариант невозможен, то совместно с разработчиками и пм прикинул бы на что могут влиять задачи, на какие подсистемы и взял бы в регресс только этих подсистем. Обсудил бы важность этих подсистем, которые могут сломаться, даже если часть подсистем могут сломаться это будет не так страшно и соответственно исключил бы из регресса неважные подсистемы

#### 23. Что такое API? Какие бывают API? При помощи каких программ можно тестировать API?

**API (Интерфейс программного приложения)** - это набор инструкций и правил который позволяют разным программам разговаривать между собой. API упрощает обмен информации между разными частями ПО. Основных API несколько: REST, SOAP, GraphQL, gRPC.

==Рассмотреть свагер==

##### 24. Что такое системы контроля версий? Для чего они нужны? Что такое git?
Рассмотреть подробнее

#### 25. Что такое Bash? Для чего он нужен? Какие bash команды знайте?

**Bash** - командная оболочка в UNIX-подобных ОС (Linux, MacOS). Она предоставляет пользователю интерфейс для взаимодействия с ОС путем выполнения команд в командной строке. Bash можно пользоваться на Windows. Если мы говорим в контексте тестирования, то bash-скрипты могут быть использованы для автоматизации, запуска тестов, анализа результата, создание отчетов и т.д.

Можно написать bash-скрипты, которые настроят тестовые среды, подготовят тестовые данные, bash-скрипты могут использоваться для создания виртуальных машин, контейнеров докер или других изолированных  сред

==Рассмотреть команд bash====

#### 26. Расскажите про пирамиду тестирования

**Пирамида тестирования** - концептуальная модель, которая помогает организовать различные уровни тестирования в иерархическом порядке. Она часто используется для визуализации и планирования стратегий тестирования. Идея пирамиды заключается в том, что тесты должны быть разного уровня:

- Unit-тестирование - проверяют работу методов, они быстрые и простые 
- Интеграционное тестирование - проверка корректности взаимодействия между различными модулями или компонентами 
- Системное тестирование - проверка системы в целом
- UI-автотесты (End-to-End тесты) - честные тесты, которые проверяют бизнес-логику от начала до конца

#### 27. Расскажите про клиент-серверную архитектуру. Расскажите про треуровневую архитектуру. Расскажите про толстый и тонкий клиент. В чем между ними разница? Микросервисы vs Монолит

В толстом клиенте большая часть бизнес-логики находится на клиентской стороне приложения, на тонком - на серверное стороне. Толстым клиентом может быть декстопное приложение для редактирования фотографий, которые выполняет обработку изображений и сохраняет их на локальных компьютере без постоянного обращения к серверу. Тонким клиентом может быть веб-приложение для управления задачами, которые предоставляют пользователю интерфейс для создания, редактирования и управления задачами. Все операции выполняются на сервере и обновления отправляются обратно клиенту через браузер.

В **монолитное** архитектуре все приложение разрабатывается как одно целое, где все компоненты объединены и запускаются вместе. Типичное веб-приложение где весь код (бэкенд, фронтенд, бд) находятся в одном месте и запускается как единое целое. Например, классическое приложение PHP, где весь код написан на PHP. Все страницы, бд и бизнес-логика находится вместе.

В **микросервисной архитектуре** приложения разбиваются на отдельные маленькие сервисы (микросервисы). Каждый микросервис выполняет отдельную функцию и может быть развернут и масштабируем вне зависимости от других сервисов. Например, онлайн-магазин где у нас есть отдельные сервисы для обработки заказов, управления каталогом товаров, аутентификаций пользователя и т.д. Каждый из этих сервисов может быть разработан, развернут и масштабирован отдельно. 

Монолиты обычно проще в разработке и развертывании, в то время как микросервисы обеспечивают большую гибкость и масштабируемость

#### 28. Что такое Cookies? Для чего они нужны? Что такое кэш? Для чего он нужен? В чем разница между Local Storage и Session Storage?

**Cookie** - маленькие кусочки информации, которые веб-сервер отправляет на ваш компьютер когда вы посещаете веб-сайт. Эти куки хранятся в вашем веб-браузере и отправляются обратно на сервер с каждым запросом, который пользователь делает на веб-сайте. Например, когда вы входить на сайт, куки могут сохранить вашу авторизацию, чтобы вы оставались вошедшим на сайте при следующих посещениях

**Кэш** - место, где данные временно хранятся для более быстрого доступа. В веб-контексте означает, что веб-страницы изображения и другие ресурсы могут сохраняться локально на вашем компьютере или на сервер, чтобы при следующих запросах они загружались быстрее.

**Local storage** - это тип хранилища на стороне клиента, который позволяет веб-приложениям хранить данные локально в браузере пользователя. Он похож на файлы cookie, но более мощный и безопасный. В отличие от файлов cookie, которые отправляются обратно на сервер при каждом запросе, данные, хранящиеся в локальном хранилище, остаются на устройстве пользователя и не отправляются обратно на сервер. Локальное хранилище в основном используется для хранения данных, которые необходимо сохранять между загрузками страниц или между сеансами.

**Session storage** - такое же место в вашем веб-браузере для хранения данных, но оно сохраняет данные только во время одной сессии браузера. Когда вы закрываете вкладку или браузер, данные в session storage удаляются

#### 29. Как вызвать Chrome Devtools? Для чего нужен? Как использовать?

Chrome Devtools - набор инструментов для разработчиков, встроен непосредственно в браузер. Он предоставляет мощные средства для отладки, анализа и улучшения сайтов и веб-приложений. При помощи Chrome Devtools можно отлаживать JavaScript код, редактировать HTML и СSS в реальном времени, анализировать производительность, тестировать адаптивность дизайна сайта на различных устройствах и разрешения экрана и многое другое
==Рассмотреть подробнее==

#### 30. Виды баз данных. Отличия реляционных и нереляционных баз данных. Преимущество нереляционных баз данных над реляционными?

В реляционных БД данные хранятся в виде таблиц, состоящих из строк и столбцов. В релицоинных данные связаны между собой ключей